#!/usr/bin/perl
use strict;     #wymagaj inicjalizacji zmiennej przed użyciem
use warnings;   #wypisuj informacje
use Cwd;
use File::Copy;
use File::Path;
use File::stat;

my $niskarDirName = ".niskar/";
my $watchlistFileName = $niskarDirName . "watchlist";
my $lastIdFileName = $niskarDirName . "lastid";
my $shotsDirName = $niskarDirName . "shots/";
my $infoFileName = ".info";
my %errors = (fileErr => -2, commandErr => -1, argError => -3, copyErr => -4);

#wypisz tekst
sub printInfo
{
	print("$_[0]\n");
}

#wypisz błąd na czewono
sub printError
{
	print(STDERR "\033[31m$_[0]\033[39m\n");
}

#wypisz pomoc
sub printHelp
{
	printInfo("niskar - użycie");
	printInfo("start\n\tTworzy nowe repozytorium.");
	printInfo("watched\n\tWypisuje obserwowane pliki.");
	printInfo("watch <pliki/katalogi>\n\tDodaje podane obiekty do obserwowanych.");
	printInfo("unwatch <pliki/katalogi>\n\tUsuwa podane obiekty z obserwowanych.");
	printInfo("shot <komentarz>\n\tTworzy zdjęcie kopiując obserwowane pliki.");
	printInfo("history\n\tWypisuje listę zdjęć z komentarzami i datami.");
	printInfo("burn <zdjęcia>\n\tUsuwa zdjęcia z repozytorium.");
	printInfo("summon <zdjęcie> <pliki/katalogi>\n\tZastępuje obecne pliki podanymi plikami ze zdjęcia.");
	printInfo("teleport <zdjęcie>\n\tZastępuje wszystkie pliki i katalogi ze zdjęcia.");
	printInfo("info <zdjęcie> <plik/katalog>\n\tWypisuje informacje o danym obiekcie.");
}

#stwórz repozytorium
sub commandStart
{
	if(-d $niskarDirName)
	{
		printError("Katalog $niskarDirName już istnieje!");
		exit $errors{fileErr};
	}
	if(!mkdir($niskarDirName))
	{
		printError("Nie można stworzyć katalogu $niskarDirName.");
		exit $errors{fileErr};
	}
	if(!open(WATCHLIST_FILEHANDLE, ">", $watchlistFileName))
	{
		printError("Nie można stworzyć pliku $watchlistFileName.");
		exit $errors{fileErr};
	}
	close(WATCHLIST_FILEHANDLE);
	if(!open(LASTID_FILEHANDLE, ">", $lastIdFileName))
	{
		printError("Nie można stworzyć pliku $lastIdFileName.");
		exit $errors{fileErr};
	}
	print LASTID_FILEHANDLE "0";
	close(LASTID_FILEHANDLE);
	if(!mkdir($shotsDirName))
	{
		printError("Nie można stworzyć katalogu $shotsDirName.");
		exit $errors{fileErr};
	}
}

#wypisz obserwowane pliki
sub commandWatched
{
	if(!open(WATCHLIST_FILEHANDLE, "<", $watchlistFileName))
	{
		printError("Nie można otworzyć $watchlistFileName.");
		exit $errors{fileErr};
	}
	while(<WATCHLIST_FILEHANDLE>)
	{
		chomp($_);
		printInfo("$_");
	}
	close(WATCHLIST_FILEHANDLE);
}

#dodaj nowy plik do obserwowanych
sub commandWatch
{
	#wczytaj pliki z argumentów
	my $argsCount = @ARGV;
	my @filesToWatch;
	for(my $i = 1; $i < $argsCount; $i++)
	{
		$filesToWatch[$i - 1] = $ARGV[$i];
	}
	my $filesCount = @filesToWatch;

	#wczytaj już obserwowane z pliku
	if(!open(WATCHLIST_FILEHANDLE, "<", $watchlistFileName))
	{
		printError("Nie można otworzyć $watchlistFileName.");
		exit $errors{fileErr};
	}
	my @watchedFiles;
	my $f = 0;
	while(<WATCHLIST_FILEHANDLE>)
	{
		chomp($_);
		$watchedFiles[$f] = $_;
		$f++;
	}
	my $watchedFilesCount = @watchedFiles;
	close(WATCHLIST_FILEHANDLE);

	#dodaj do obserwowanych patrząc na istnienie, bycie w katalogu i duplikaty
	my $currDir = cwd();
	my $k = 0; #ilość dodanych plików
	for(my $i = 0; $i < $filesCount; $i++)
	{
		my $fileIsGood = 1;
		for(my $j = 0; $j < $watchedFilesCount; $j++)
		{
			if($filesToWatch[$i] eq $watchedFiles[$j])
			{
				$fileIsGood = 0;
				last; #break;
			}
		}
		if($fileIsGood eq 1)
		{
			if(-e $filesToWatch[$i])
			{
				if(-e $currDir . "/" . $filesToWatch[$i] and index($currDir . "/" . $filesToWatch[$i], "/../") eq -1)
				{
					$watchedFiles[$k + $watchedFilesCount] = $filesToWatch[$i];
					$k++;
				}
				else
				{
					printError("Plik $filesToWatch[$i] jest poza obecnym katalogiem!");
					exit $errors{argError};
				}
			}
			else
			{
				printError("Plik $filesToWatch[$i] nie istnieje!");
				exit $errors{argError};
			}
		}
	}

	#wypisz nową listę do pliku
	if(!open(WATCHLIST_FILEHANDLE, ">", $watchlistFileName))
	{
		printError("Nie można zapisać do $watchlistFileName.");
		exit $errors{fileErr};
	}
	foreach my $watchedFile (@watchedFiles)
	{
		print WATCHLIST_FILEHANDLE "$watchedFile\n";
	}
	close(WATCHLIST_FILEHANDLE);
}

#usuń obserwowaną wartość z pliku
sub commandUnwatch()
{
	#wczytaj pliki z argumentów
	my $argsCount = @ARGV;
	my @filesToUnwatch;
	for(my $i = 1; $i < $argsCount; $i++)
	{
		$filesToUnwatch[$i - 1] = $ARGV[$i];
	}
	my $filesCount = @filesToUnwatch;

	#wczytaj już obserwowane z pliku
	if(!open(WATCHLIST_FILEHANDLE, "<", $watchlistFileName))
	{
		printError("Nie można otworzyć $watchlistFileName.");
		exit $errors{fileErr};
	}
	my @watchedFiles;
	my $f = 0;
	while(<WATCHLIST_FILEHANDLE>)
	{
		chomp($_);
		$watchedFiles[$f] = $_;
		$f++;
	}
	my $watchedFilesCount = @watchedFiles;
	close(WATCHLIST_FILEHANDLE);

	#przepisuj do nowego pomijając pliki do usunięcia
	my @newList;
	my $k = 0;
	for(my $i = 0; $i < $watchedFilesCount; $i++)
	{
		my $toBeDeleted = 0;
		for(my $j = 0; $j < $filesCount; $j++)
		{
			if($watchedFiles[$i] eq $filesToUnwatch[$j])
			{
				$toBeDeleted = 1;
			}
		}
		if($toBeDeleted eq 0)
		{
			$newList[$k] = $watchedFiles[$i];
			$k++;
		}
	}

	#wypisz nową listę do pliku
	if(!open(WATCHLIST_FILEHANDLE, ">", $watchlistFileName))
	{
		printError("Nie można zapisać do $watchlistFileName.");
		exit $errors{fileErr};
	}
	foreach my $file (@newList)
	{
		print WATCHLIST_FILEHANDLE "$file\n";
	}
	close(WATCHLIST_FILEHANDLE);
}

#zrób zdjęcie (commit)
sub commandShot()
{
	#otwórz plik z ostatnim id
	if(!open(LASTID_FILEHANDLE, "<", $lastIdFileName))
	{
		printError("Nie można otworzyć $lastIdFileName.");
		exit $errors{fileErr};
	}
	my $lastId;
	while(<LASTID_FILEHANDLE>)
	{
		chomp($_);
		$lastId = $_;
	}
	$lastId++;
	close(LASTID_FILEHANDLE);

	#stwórz katalog
	my $dirName = sprintf ("$shotsDirName" . "shot%04d/", $lastId);
	if(!mkdir($dirName))
	{
		printError("Nie można stworzyć katalogu zdjęcia $dirName.");
		exit $errors{fileErr};
	}

	#weź tekst commita
	my $commitText = join(" ", @ARGV);
	#$commitText = chomp($commitText);
	$commitText = substr($commitText, 5); #długość "shot"

	#zapisz commit i czas
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
	my $timeString = ($year + 1900) . "-" . ($mon + 1) . "-" . $mday . " " . $hour . ":" . $min . ":" . $sec;
	if(!open(COMMIT_FILEHANDLE, ">", $dirName . $infoFileName))
	{
		printError("Nie można zapisać tekstu zdjęcia.");
		exit $errors{fileErr};
	}
	print COMMIT_FILEHANDLE "$commitText\n";
	print COMMIT_FILEHANDLE $timeString;
	close(COMMIT_FILEHANDLE);

	#wczytaj obserwowane pliki
	if(!open(WATCHLIST_FILEHANDLE, "<", $watchlistFileName))
	{
		printError("Nie można otworzyć $watchlistFileName.");
		exit $errors{fileErr};
	}
	my @watchedFiles;
	my $f = 0;
	while(<WATCHLIST_FILEHANDLE>)
	{
		chomp($_);
		$watchedFiles[$f] = $_;
		$f++;
	}
	my $watchedFilesCount = @watchedFiles;
	close(WATCHLIST_FILEHANDLE);

	#kopiuj pliki
	foreach my $x (@watchedFiles)
	{
		my $newDirName = $dirName . $x;
		#perl nie obsługuje natywnie rekursywnego kopiowania katalogów. Tak jest szybciej,
		system("cp -r $x $newDirName");
		if($? ne 0)
		{
			printError("Nie można skopiować $x do $newDirName!");
			#usuwamy katalog, ponieważ i tak jest niepełny
			rmtree($dirName);
			exit $errors{copyErr};
		}
	}

	#zapisz nowy id
	if(!open(LASTID_FILEHANDLE, ">", $lastIdFileName))
	{
		printError("Nie można zaktualizować numeru id");
		exit $errors{fileErr};
	}
	print LASTID_FILEHANDLE $lastId;
	close(LASTID_FILEHANDLE);

}

#wypisuje zdjęcia
sub commandHistory()
{
	if(!opendir(SHOTS_DIR, $shotsDirName))
	{
		printError("Nie można wypisać zawartości $shotsDirName.");
		exit $errors{fileErr};
	}
	#wkładamy nazwy do tablicy, ale bez .. i .
	my @subdirs = grep{!/^\./} readdir(SHOTS_DIR);
	@subdirs = sort @subdirs;
	foreach my $subdir (@subdirs)
	{
		printInfo("$subdir");
		if(!open(INFO_FILEHANDLE, "<", $shotsDirName . $subdir . "/" . $infoFileName))
		{
			printError("Nie można uzyskać tekstu zdjęcia!");
		}
		else
		{
			while(<INFO_FILEHANDLE>)
			{
				chomp($_);
				printInfo("\t" . $_);
			}
			close(INFO_FILEHANDLE);
		}
	}
	closedir(SHOTS_DIR);
}

sub commandBurn
{
	#wczytaj pliki z argumentów
	my $argsCount = @ARGV;
	my @filesToBurn;
	for(my $i = 1; $i < $argsCount; $i++)
	{
		$filesToBurn[$i - 1] = $ARGV[$i];
	}

	#wczytaj listę commitów
	if(!opendir(SHOTS_DIR, $shotsDirName))
	{
		printError("Nie można wypisać zawartości $shotsDirName.");
		exit $errors{fileErr};
	}
	my @subdirs = grep{!/^\./} readdir(SHOTS_DIR);

	#sprawdź poprawność
	my $corr = 1;
	foreach my $fileToBurn (@filesToBurn)
	{
		if(!-e $shotsDirName . $fileToBurn)
		{
			printError("Zdjęcie $fileToBurn nie istnieje!");
			$corr = 0;
		}
	}
	if($corr == 0)
	{
		exit $errors{argError};
	}

	#usuń podane
	foreach my $subdir (@subdirs)
	{
		foreach my $fileToBurn (@filesToBurn)
		{
			if($subdir eq $fileToBurn)
			{
				rmtree($shotsDirName . $subdir);
			}
		}
	}
	closedir(SHOTS_DIR);
}

sub commandSummon
{
	#wczytaj pliki z argumentów
	my $argsCount = @ARGV;
	my @filesToSummon;
	for(my $i = 2; $i < $argsCount; $i++)
	{
		$filesToSummon[$i - 2] = $ARGV[$i];
	}
	my $shotToSummon = $ARGV[1];

	#sprawdź, czy katalog istnieje
	if(!-d $shotsDirName . $shotToSummon)
	{
		printError("Zdjęcie $shotToSummon nie istnieje!");
		exit $errors{argError};
	}
	my $shotDir = $shotsDirName . $shotToSummon . "/";

	#sprawdź czy pliki istnieją w zdjęciach
	foreach my $fileToSummon (@filesToSummon)
	{
		if($fileToSummon eq $infoFileName or !-e $shotDir . $fileToSummon)
		{
			printError("Obiekt $fileToSummon nie istnieje!");
			exit $errors{argError};
		}
	}

	#skopiuj plik
	foreach my $fileToSummon (@filesToSummon)
	{
		my $fileToCopy = $shotDir . $fileToSummon;
		#opcja T traktuje docelowy katalog jak plik i nie tworzy drugiego o tej samej nazwie wewnątrz
		system("cp -rT $fileToCopy $fileToSummon");
		if($? ne 0)
		{
			printError("Nie można przywołać $fileToSummon!");
			exit $errors{copyErr};
		}
	}
}

sub commandTeleport()
{
	my $shot = $ARGV[1];
	my $shotDir = $shotsDirName . $shot . "/";
	#sprawdź czy zdjęcie istnieje
	if(!-d $shotDir)
	{
		printError("Zdjęcie $shot nie istnieje!");
		exit $errors{argError};
	}

	#stwórz tablicę wszystkich ważnych plików
	if(!opendir(SHOT_DIR, $shotDir))
	{
		printError("Nie można otworzyć $shot.");
		exit $errors{fileErr};
	}
	#wkładamy nazwy do tablicy, ale bez .. , . i .info
	my @files = grep{$_ ne "." and $_ ne ".." and $_ ne $infoFileName} readdir(SHOT_DIR);
	foreach my $file (@files)
	{
		my $source = $shotDir . $file;
		system("cp -rT $source $file");
		if($? ne 0)
		{
			printError("Nie można teleportować $file!");
			exit $errors{copyErr};
		}
	}
	closedir(SHOT_DIR);
}

sub commandInfo
{
	my $shot = $ARGV[1];
	my $file = $ARGV[2];
	my $shotDir = $shotsDirName . $shot . "/";

	#sprawdź, czy zdjęcie istnieje
	if(!-d $shotDir)
	{
		printError("Zdjęcie $shot nie istnieje.");
		exit $errors{argError};
	}

	#sprawdź, czy plik istnieje
	my $fileName = $shotDir . $file;
	if(!-e $fileName or $file eq $infoFileName)
	{
		printError("Plik $file nie istnieje.");
		exit $errors{argError};
	}

	#Wypisz plik
	printInfo("$file");

	if(-f $fileName)
	{
		printInfo("\tTyp:\t\tPlik");
	}
	else
	{
		printInfo("\tTyp:\t\tKatalog");
	}

	#oblicz wielkość pliku
	my $fileSize = -s $fileName;
	printInfo("\tRozmiar:\t$fileSize B");

	#oblicz datę
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(stat($fileName) -> mtime);
	my $timeString = ($year + 1900) . "-" . ($mon + 1) . "-" . $mday . " " . $hour . ":" . $min . ":" . $sec;
	printInfo("\tModyfikacja:\t$timeString");
}

my $argsCount = @ARGV;
if($argsCount == 0)
{
    printHelp();
    exit $errors{commandErr};
}

#nie ma oficjalnego switch, a given rzuca ostrzeżenia
my $command = $ARGV[0];
if($command eq "start" and $argsCount eq 1)
{
	commandStart();
}
elsif($command eq "watched" and $argsCount eq 1)
{
	commandWatched();
}
elsif($command eq "watch" and $argsCount gt 1)
{
	commandWatch();
}
elsif($command eq "unwatch" and $argsCount gt 1)
{
	commandUnwatch();
}
elsif($command eq "shot" and $argsCount gt 1)
{
	commandShot();
}
elsif($command eq "history" and $argsCount eq 1)
{
	commandHistory();
}
elsif($command eq "burn" and $argsCount gt 1)
{
	commandBurn();
}
elsif($command eq "summon" and $argsCount gt 2)
{
	commandSummon();
}
elsif($command eq "teleport" and $argsCount eq 2)
{
	commandTeleport();
}
elsif($command eq "info" and $argsCount eq 3)
{
	commandInfo();
}
else
{
	printHelp();
	exit $errors{commandErr};
}
